* 集合

1 集合的体系结构
	单列集合：Collection、List、Set；
	双列集合：Map。
2 List介绍
	可以允许存储重复的对象； 
	可以插入多个null元素；
	是一个有序容器,保持了每一个元素的插入顺序,插入的顺序即输出的顺序； 
	常用的实现类有 ArrayList、LinkedList和Vector。
3 Set介绍
	不允许重复对象； 
	只允许一个null元素； 
	无序容器，无法保证每个元素的存储顺序，但TreeSet通过Comparator或者Comparable维护了一个排序顺序。 
	常用的实现类是HashSet、LinkedHashSet以及TreeSet。
4 Map介绍
	每个Entry都持有两个对象，也就是一个键一个值；
	可以拥有随意个null值但最多只能有一个null键； 
	常用的实现类是HashMap、LinkedHashMap、Hashtable和TreeMap。
5 HashMap介绍
	底层数组+链表实现，可以存储null键和null值，线程不安全；
	初始size为16，扩容：newsize = oldsize*2，size一定为2的n次幂；
	当Map中元素总数超过Entry数组的75%，触发扩容操作。
6 HashTable介绍
	底层数组+链表实现，无论key还是value都不能为null，线程安全；
	实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化；
	初始size为11，扩容：newsize = oldsize*2+1。
7 ConcurrentHashMap介绍（分段锁）
	底层采用分段的数组+链表实现，线程安全；
	通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍(读操作不加锁)；
	ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术，但有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁；
	扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容）。
8 ArrayList和Linkedlist的区别
	ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构；
	对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针；
	对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。

* 线程

1 实现线程有哪些方式
	继承Thread类，重写父类run()方法；
    实现runnable接口；
	实现Callable接口实现有返回结果的线程；
	线程池（Spring提供的线程池：ThreadPoolTaskExecutor）。
2 实现Runnable接口和实现Callable接口的区别
	返回值：Callable有返回值，Runnable没有返回值；
	异常：Runnable没有容错机制，如果出现异常必须立即处理；Callable有容错机制出现异常之后可以向上抛出；
	启动方式：Runnable可以通过Thread来启动，也可以通过线程池来处理；Callable只能通过线程池来处理。
3 产生线程安全问题的原因
	多个线程在操作共享的数据；
	操作共享数据的线程代码有多条。
4 线程安全问题的解决办法
	synchronized同步方法；
	synchronized同步代码块；
	Lock锁；
	分布式锁（可基于redis、zookeeper、mysql创建分布式锁）。
5 介绍ThreadLocal
	在线程并发时，解决变量共享问题。ThreadLocal用于保存某个线程共享变量，不同线程只能从中get，set，remove自己的变量，而不会影响其他线程的变量。
	ThreadLocal的主要问题的会产生脏数据和内存泄漏。

* 数据库

1 事物的特性
	ACID：原子性、一致性、隔离性、持久性
2 事务的隔离级别
	未提交读、已提交读、可重复读、串行化
3 事务并发访问引起的问题以及如何避免
	更新丢失：MySQL所有事务隔离级别在数据库层面上均可避免。
	脏读：READ-COMMITTED事务隔离级别以上可避免。
	不可重复读：REPEATABLE-READ事务隔离级别以上可避免。
	幻读：SERIALIZABLE事务隔离级别可避免。
3 MySQL数据库的索引
	普通索引：最基本的MySQL数据库索引，它没有任何限制；
	唯一索引：它与普通索引类似，不同的就是：MySQL数据库索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一；
	主键索引：它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引；
	组合索引。
4 列举导致索引失效的情况
	如果条件中有or，即使其中有条件带索引也不会使用；
	对于多列索引，不是使用的第一部分，则不会使用索引；
	like查询是以%开头；
	如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引；
	如果mysql估计使用全表扫描要比使用索引快,则不使用索引。
5 数据库常用的存储引擎及应用场景
	MyISAM 应用场景：频繁执行全表count语句；对数据进行增删改的频率不高，查询非常频繁；没有事务。
	InnoDB 应用场景：数据增删改查都相当频繁；可靠性要求比较高，要求支持事务。
6 列举数据库优化办法
	创建并使用正确的索引；
	SQL语句的优化；
	选择合适的数据库引擎。
7 列举SQL查询语句的优化
	对查询进行优化，应尽量避免全表扫描，首先应考虑在where及order by涉及的列上建立索引；
	应尽量避免在where子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描；
	应尽量避免在where子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描；
	应尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描；
	很多时候用exists代替in是一个好的选择；
	当只要一行数据时使用limit1。
8 数据库的乐观锁
	乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。
	使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。
	即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。
	当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加1。
	当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。
9 数据库的悲观锁
	悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。
	悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。
	共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。
10 乐观锁和悲观锁的应用场景
	乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。
	但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。

* Redis

1 Redis数据类型
	字符串类型（string）、散列类型（hash）、列表类型（list）、集合类型（set）、有序集合类型（zset）。
2 Redis持久化的方式和区别
	快照RDB：RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储；
	写日志AOF：AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。
3 Redis有哪些应用场景
	缓存、计数器（转发、点赞、评论）、消息队列系统、排行榜、社交网络
4 Redis缓存穿透、击穿和雪崩问题
	缓存穿透：key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。
	缓存击穿：key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。
	缓存雪崩：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。
5 缓存穿透解决方案
	采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。
	提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。
	对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。
6 缓存击穿解决方案
	利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。
7 缓存雪崩解决方案
	在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。
	不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。

* 框架

1 Spring IOC介绍
	Spring提供了对IOC(控制反转)良好支持，IOC就是对对象的创建、维护、销毁等生命周期的控制，这个过程一般是由我们的程序去主动控制。
	DI也是IOC的重要实现。依赖注入，通过将依赖关系写入配置文件，然后在创建有依赖关系的对象时，由IOC容器注入依赖的对象。
	如在创建A时，检查到有依赖关系，IOC容器就把A依赖的对象B创建后注入到A中（组装，通过反射机制实现），然后把A返回给对象请求者，完成工作。
2 Spring AOP介绍
	Spring提供了对AOP技术的良好封装，AOP称为面向切面编程，就是系统中有很多各不相干的类的方法，在这些众多方法中要加入某种系统功能的代码，如加入日志，权限判断，异常处理，这种应用称为AOP。
	实现AOP功能采用的是代理技术，客户端程序不再调用目标，而是调用代理类，代理类与目标类对外具有相同的方法声明。
3 Spring事务传播机制
	Spring的@Transactional默认是PROPAGATION_REQUIRED。
	表示当前方法必须在一个事务中运行。如果一个现有事务正在进行中，该方法将在那个事务中运行，否则就要开始一个新事务。
4 Spring Bean的生命周期
	实例化一个Bean－－也就是我们常说的new；
	按照Spring上下文对实例化的Bean进行配置－－也就是IOC注入；
	如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，此处传递的就是Spring配置文件中Bean的id值
	如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory(setBeanFactory(BeanFactory)传递的是Spring工厂自身（可以用这个方式来获取其它Bean，只需在Spring配置文件中配置一个普通的Bean就可以）；
	如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文（同样这个方式也可以实现步骤4的内容，但比4更好，因为ApplicationContext是BeanFactory的子接口，有更多的实现方法）；
	如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术；
	如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。
	如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法；
	当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用那个其实现的destroy()方法；
	如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。
5 SpringMVC执行流程
	用户向服务器发送请求，请求被SpringMVC 前端控制器DispatcherServlet截获。
	DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；
	DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter；（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler方法）
	提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，SpringMVC将帮你做一些额外的工作：
		消息转换（HttpMessageConveter）： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息。
		数据转换：对请求消息进行数据转换。如String转换成Integer、Double等。
		数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。
		数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中。
	Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；
	根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到SpringMVC容器中的ViewResolver)返回给DispatcherServlet；
	ViewResolver 结合Model和View，来渲染视图；
	将渲染结果返回给客户端。
6 SpringMVC常用注解
	@Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller对象，即一个控制器类。
	@RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。
	@RequestParam用于将指定的请求参数赋值给方法中的形参。
	@PathVariable可以获取URL中的动态参数。
	@RequestBody用于读取Request请求的body部分数据，
	@ResponseBody用于将Controller的方法返回的对象，通过适当的消息转换器转换。
	@RestController=@Controller+@ResponseBody，用于标记在一个类上。
7 MyBatis执行流程
	获取sqlSessionFactory对象: 
	获取sqlSession对象； 
	获取接口的代理对象（MapperProxy）； 
	执行增删改查方法。
8 MyBatis如何防止SQL注入
	#{}是经过预编译的，是安全的，${}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。

* Solr
  
1 什么是solr
	Solr是一个开源搜索平台，用于构建搜索应用程序。它建立在Lucene(全文搜索引擎)之上。Solr是企业级的，快速的和高度可扩展的。Solr是一个可扩展的，可部署，搜索/存储引擎，优化搜索大量以文本为中心的数据。
2 介绍一下索引和倒排序索引
	将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。
	这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。
	这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。
	虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。
	创建索引是对语汇单元索引，通过词语找文档，这种索引的结构叫倒排索引结构。
	传统方法是根据文件找到该文件的内容，在文件内容中匹配搜索关键字，这种方法是顺序扫描方法，数据量大、搜索慢。
3 solr怎么设置搜索结果排名靠前
	可以设置文档中域的boost值，boost值越高计算出来的相关度得分就越高，排名也就越靠前。此方法可以把热点商品或者是推广商品的排名提高。
4 solr里面IK分词器的原理
	IK分词器的分词原理本质上是词典分词。先在内存中初始化一个词典，然后在分词过程中逐个读取字符，和字典中的字符相匹配，把文档中的所有的词语拆分出来的过程。

5 Elasticsearch和Solr区别

- 当实时建立索引时，Solr会产生IO阻塞，es不会，es查询性能高于Solr
- 在不断动态添加数据的时候，Solr的检索效率会变得低下
- solr利用zookeeper进行分布式管理，而es自带分布式系统管理功能
- Solr一般都要部署在Web服务系统
- Solr支持更多的格式数据（xml,json）,es仅支持json
- solr是传统搜索的有力解决方案，es适用于新兴的实时搜索应用
  - 单纯的对已有的数据进行检索时候，Solr效率更好

* 分布式

1 分布式和集群的区别
	将一套系统拆分成不同子系统部署在不同服务器上（这叫分布式），然后部署多个相同的子系统在不同的服务器上（这叫集群），部署在不同服务器上的同一个子系统应做负载均衡。 
	分布式：一个业务拆分为多个子业务，部署在多个服务器上 。 
	集群：同一个业务，部署在多个服务器上 
2 Dubbo的结构
	Provider: 暴露服务的服务提供方。
	Consumer: 调用远程服务的服务消费方。
	Registry: 服务注册与发现的注册中心。
	Monitor: 统计服务的调用次调和调用时间的监控中心。
	Container: 服务运行容器。
3 Dubbo的执行流程
	服务容器负责启动，加载，运行服务提供者。
	服务提供者在启动时，向注册中心注册自己提供的服务。
	服务消费者在启动时，向注册中心订阅自己所需的服务。
	注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
	服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
	服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。
	注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外，注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者。
3 介绍一下zookeeper
	zookeeper是Hadoop的一个子项目，它是分布式系统中的协调系统，可提供的服务主要有：配置服务、名字服务、分布式同步、组服务等。
	在Dubbox中zookeeper注册中心的作用主要就是注册和发现服务的作用。
4 如果运行正常的分布式服务注册中心zookeeper死机还能继续调用服务吗 
	启动dubbo时，消费者会从zk拉取注册的生产者的地址接口等数据，缓存在本地。
	每次调用时，按照本地存储的地址进行调用。服务提供者无状态，任一台宕机后,不影响使用，服务提供者全部宕机，服务消费者会无法使用，并无限次重连等待服务者恢复。
	
* ActiveMQ

1 AcitveMQ的作用、原理 
	ActiveMQ的作用就是系统之间进行通信。当然可以使用其他方式进行系统间通信，如果使用Activemq的话可以对系统之间的调用进行解耦，实现系统间的异步通信。
	原理就是生产者生产消息，把消息发送给ActiveMQ。ActiveMQ接收到消息，然后查看有多少个消费者，然后把消息转发给消费者，此过程中生产者无需参与。消费者接收到消息后做相应的处理和生产者没有任何关系。
2 ActiveMQ在项目中应用场景？
	ActiveMQ在项目中主要是完成系统之间通信，并且将系统之间的调用进行解耦。
	例如在添加、修改商品信息后，需要将商品信息同步到索引库、同步缓存中的数据以及生成静态页面一系列操作。在此场景下就可以使用ActiveMQ。
	一旦后台对商品信息进行修改后，就向ActiveMQ发送一条消息，然后通过ActiveMQ将消息发送给消息的消费端，消费端接收到消息可以进行相应的业务处理。
3 ActiveMQ如果数据提交不成功怎么办？
	ActiveMQ有两种通信方式，点到点形式和发布订阅模式。
	如果是点到点模式的话，如果消息发送不成功此消息默认会保存到ActiveMQ服务端，直到有消费者将其消费，所以此时消息是不会丢失的。
	如果是发布订阅模式的通信方式，默认情况下只通知一次，如果接收不到此消息就没有了。这种场景只适用于对消息送达率要求不高的情况。如果要求消息必须送达不可以丢失的话，需要配置持久订阅。每个订阅端定义一个id，在订阅时向ActiveMQ注册。发布消息和接收消息时需要配置发送模式为持久化。此时如果客户端接收不到消息，消息会持久化到服务端，直到客户端正常接收后为止。

* JVM
  1 类加载器和双亲委派模型
  https://blog.csdn.net/xu768840497/article/details/79175335
  2 JDK7和JDK8的内存划分
  https://blog.csdn.net/l1394049664/article/details/81486470

  #### 什么是RabbitMQ

  以AMQP协议为标准,是消息投递服务,在服务间作中间路由的角色,(消息中间件)

  #### **AMQP**

  ​	AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品、不同开发语言等条件的限制。

  ​	换句话说，AMQP可以使符合规范的客户端应用程序与符合规范的消息中间件代理进行通信。

  #### 使用RabbitMQ有什么好处

  - 解决耦合性，避免直接接触
  - 异步处理，发送端不需要等待接收端返回结果
  - 解决两端语言不通的问题
  - 发送错误可以确认是谁的责任

  #### 消息基于什么传输

  RabbitMQ使用管道的方式来传输消息，建立在真实的TCP连接内的虚拟连接

  #### 消息怎么路由

  发送端发送给交换机，交换机发送给队列，队列再发给接收端

  #### vhost是什么，起什么作用

  vhost是一个虚拟的主机,虚拟的小型RabbitMQ

  可以在多个不同的应用中使用RabbitMQ

  #### 消息如何分发

  若队列至少有一个消费者,消息将以循环的方式发送给消费者.每条消息只会分发给一个订阅的消费者

  #### RabbitMQ（MQ）的几种应用场景

  - HelloWorld模式，一对一，单发送单接收
  - 工作队列模式，一对多，单发送多接收，像分布式发布任务
  - 发布订阅模式，发送端通过交换机，由交换机发送给队列，再发送给接收端
  - 路由模式，发送端发送给交换机，对数据进行筛选，选择性的发送给接收端
  - 主题模式，发送端发送给交换机，然后可以进行*或者#进行匹配，再发送给接收端
  - RPC模式

  ​

  #### 什么是高并发

  高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。

   

  高并发相关常用的一些指标有响应时间（Response Time），吞吐量（Throughput），每秒查询率QPS（Query Per Second），并发用户数等。

   

  响应时间：系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间。

  吞吐量：单位时间内处理的请求数量。

  QPS：每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。

  并发用户数：同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。

  ​

