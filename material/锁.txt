Java中的4种锁状态

	Java中，针对synchronized有无锁，偏向锁，轻量级锁，重量级锁4种锁状态
	级别从低到高依次是：无锁 > 偏向锁 > 轻量级锁 > 重量级锁。
	而且锁的状态只有升级，没有降级。
	
Synchronized为什么能实现线程的同步？
	Java对象头：Java对象保存在内存中时，由3部分组成：
		对象头（Header）
		实例数据（Instance Data）：对象真正存储的有效信息
		对象填充字节（Padding）：JVM要求对象的大小必须是8字节的整数倍，对象头已经满足，则当对象的实例数据部分没有对齐时，需要对齐填充来补全。
		
		而对象头又由3部分组成：
		Mark Word（标记字段）：
		Class Metadata Address（类型指针）： 对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
		Array Length（ 数组长度）： 只有数组对象保存了这部分数据。
		
		Mark Word：当这个对象被synchronized关键字当成同步锁时，围绕这个锁的一系列操作都和Mark Word有关。
			Mark Word 记录的是对象和锁有关的信息，默认存储对象的HashCode，分带年龄，锁标志位信息，由于这些信息都是与对象自身定义无关的数据，所以所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。

	Monitor
		Monitor翻译为监视器，也叫管程，可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。
		Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。
		现在再回来看synchronized，synchronized通过Monitor来实现线程同步，而Monitor依赖于底层操作系统的Mutex Lock（互斥锁）实现线程同步
		
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

产生死锁的必要条件：

互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
无锁：
	无锁就是没有真正意义上的上锁，所有的线程还是能访问并修改同一个资源，但是通过算法控制，实现同时只有一个线程修改成功。
	CAS全称 Compare and Swap（比较与交换），是一种无锁算法。
	无锁的特点就是修改操作其实一直在一个循环，线程不断循环尝试修改资源，没有冲突就修改成功，否则继续不断循环尝试。有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。
	
 偏向锁：
	偏向锁是指一段同步代码一直只被一个线程所访问，那么该线程会自动获取锁，降低获取锁的成本。
	当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，
	而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，
	而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。

	偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。	
	偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。
	撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。
	
轻量级锁：
	是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。
	
	在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，
	用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。
	如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。

	如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。

	若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。

重量级锁：
	升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。

总结：
	锁状态的改变是根据竞争激烈程度进行的，在几乎无竞争的条件下，会使用偏向锁，在轻度竞争的条件下，会由偏向锁升级为轻量级锁， 在重度竞争的情况下，会升级到重量级锁。

	偏向锁通过对比Mark Word 解决加锁问题，避免执行CAS操作。

	而轻量级锁是通过CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒带来的性能影响。

	重量级锁是将除拥有锁的线程之外的线程全部阻塞。

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Java锁的种类：

	乐观锁/悲观锁：
		乐观锁与悲观锁并不是特指某两种类型的锁，是人们定义出来的概念或思想，主要是指看待并发同步的角度。　
		
		乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。
		乐观锁适用于多读的应用类型，这样可以提高吞吐量，在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS(Compare and Swap 比较并交换)实现的。
		悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。比如Java里面的同步原语synchronized关键字的实现就是悲观锁。
		
	独享锁/共享锁：
		独享锁是指该锁一次只能被一个线程所持有。
	　　共享锁是指该锁可被多个线程所持有。

	　　对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。
	　　读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。
	互斥锁/读写锁：
		上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。
		
	可重入锁：
		可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。
		对于Synchronized而言，也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。
		
	公平锁/非公平锁：
	　　公平锁是指多个线程按照申请锁的顺序来获取锁。
　　	非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。

	分段锁：
		分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。
		
	偏向锁/轻量级锁/重量级锁：
		这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。

	　　偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
	　　轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。 	  
		重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，
		该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。
	自旋锁：
		在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。
		
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。

	对于普通同步方法，锁是当前实例对象。
	对于静态同步方法，锁是当前类的Class对象。
	对于同步方法块，锁是Synchonized括号里配置的对象。
    从JVM规范中可以看到Synchonized在JVM里的实现原理，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。

	synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。
    在32位虚拟机中，1字宽等于4字节，即32bit。

	Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。

1，偏向锁

    当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

2，轻量级锁
    当有竞争且竞争不强烈时，JVM就会由偏向锁膨胀为轻量级锁，考虑到线程的阻塞和唤醒需要CPU从用户态转为核心态，而这种转换对CPU来说是一件负担很重的操作，因此没有获取到锁的线程不会进入阻塞状态，而是通过自旋的方式一直尝试获取锁，处于一种忙等状态，所以这种处理竞争的方式比较浪费CPU，但是响应速度很快。

3，重量级锁

    当竞争竞争激烈时，线程直接进入阻塞状态。不过在高版本的JVM中不会立刻进入阻塞状态而是会自旋一小会儿看是否能获取锁如果不能则进入阻塞状态。

三种锁优缺点对比：

偏向锁：
	优点：		加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级别的差距
	缺点：		如果线程间存在锁竞争，会带类额外的锁撤销的消耗
	使用场景：	适用于只有一个线程访问同步块的场景
轻量级锁：
	优点：		竞争的线程不会阻塞，提高了程序的响应速度
	缺点：		如果始终得不到锁竞争的线程，使用自旋会消耗CPU
	使用场景：	追求响应时间，同步块执行速度非常快
重量级锁：
	优点：		线程竞争几乎不使用自旋，不会消耗CPU
	缺点：		阻塞线程，响应时间缓慢
	使用场景：	追求吞吐量，同步块执行速度较长

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	